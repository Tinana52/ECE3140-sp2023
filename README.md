## Your Project Answers

### Project Description

I intend on creating a Space Invaders game using the KL46Z board as a controller, and a computer as a console and display. In classic Space Invaders, the player uses the left and right arrow keys to move a spaceship character left and right, and spacebar to shoot. The objective of the game is to score maximum points by destroying as many aliens as possible before time runs out, or before the aliens run into your ship. I will mimic the arrow keys with either the capacitive touch slider or the accelerometer, and the spacebar with a button on the board. I will also use the LEDs on the board to blink in a manner representing the game time remaining, and to blink for every shot taken. I will create a simple space invaders GUI on my computer which would implement the game logic itself and respond in real-time to board inputs. Communicating over serial with no additional hardware, I expect the board and computer together will be an enjoyable and feature-rich retro game using a novel control method. 
### Technical Approach

For my final project I will only be using the KL46Z board and my computer. I will interface them by USB cable and communicate using the serial port automatically created by the debugger. To achieve this I will reference the uart_example.c file provided by course staff.

In order for the board to act as a controller I will use its LEDs, a button, and either its capacitive touch slider or accelerometer. From an experience standpoint this decision would differentiate the manner in which the character is moved - by contact or by tilt. I will experiment with both to ascertain which is more reliable and enjoyable. To control the LEDs I will manipulate their register using scripts from earlier labs in conjunction with a PIT timer and the registers associated with one of the buttons. Having reviewed the user manual, there are example scripts for buttons that I will use. Using the more complex sensors will also be a matter of reading the user manual and reference, as well as modifying example code to suit the project. 

The game itself will be run on my Mac, built using Python and some libraries for serial reading and a minimalistic GUI. The logic for the game is fairly straightforward and should not take long to develop. Upon startup, the game will wait to read a ready indication from the controller. It will then provide player instruction on screen and await a board button press to start the game. On the board, this will cause the PIT timer to be enabled and loaded with the game period - 30 seconds, and the same countdown to begin in the python game script. This will also then trigger the state of each useful board sensor being written in serial at the prescribed baud rate of 115200, each preceded by a sensor identifier. The game will parse this stream of sensor data and update the position of the character and produce projectiles in real-time. The duration between blinks of the LED will either be controlled by a second PIT timer, or finer control on the first - causing the blinks to increase in urgency as the timer winds down. The other LED will light as the shoot button interrupt is raised. Once the timer expires, the game will display the final score achieved, and the board will stop sending all data streams. From here the cycle repeats - the instructions are displayed and the game awaits button press. 

 

 
For my final project I will only be using the KL46Z board and my computer. I will interface them by USB cable and communicate using the serial port automatically created by the debugger. To achieve this I will reference the uart_example.c file provided by course staff.

In order for the board to act as a controller I will use its LEDs, a button, and either its capacitive touch slider or accelerometer. From an experience standpoint this decision would differentiate the manner in which the character is moved - by contact or by tilt. I will experiment with both to ascertain which is more reliable and enjoyable. To control the LEDs I will manipulate their register using scripts from earlier labs in conjunction with a PIT timer and the registers associated with one of the buttons. Having reviewed the user manual, there are example scripts for buttons that I will use. Using the more complex sensors will also be a matter of reading the user manual and reference, as well as modifying example code to suit the project. 

The game itself will be run on my Mac, built using Python and some libraries for serial reading and a minimalistic GUI. The logic for the game is fairly straightforward and should not take long to develop. Upon startup, the game will wait to read a ready indication from the controller. It will then provide player instruction on screen and await a board button press to start the game. On the board, this will cause the PIT timer to be enabled and loaded with the game period - 30 seconds, and the same countdown to begin in the python game script. This will also then trigger the state of each useful board sensor being written in serial at the prescribed baud rate of 115200, each preceded by a sensor identifier. The game will parse this stream of sensor data and update the position of the character and produce projectiles in real-time. The duration between blinks of the LED will either be controlled by a second PIT timer, or finer control on the first - causing the blinks to increase in urgency as the timer winds down. The other LED will light as the shoot button interrupt is raised. Once the timer expires, the game will display the final score achieved, and the board will stop sending all data streams. From here the cycle repeats - the instructions are displayed and the game awaits button press. 

 

 

## Feedback.

## Welcome team! Please edit me.
### You can use the 'main' branch for you code.
### The GitHub web-page should be in the 'gh-pages' branch
You can access the page adding a "pages" prefix to the url for the git repo e.g. if your browser currently shows https://github.coecis.cornell.edu/ece3140-sp22/kg379 then the GitHub page is at https://pages.github.coecis.cornell.edu/ece3140-sp22/kg379 . You can edit the source in the gh-pages branch or use the "automatic page generator" acessible via settings->options in the GitHub Pages Section toward the bottom. We recommend the latter approach since it is quick and easy. We made an initial wepage that you can edit and a description of the headings we expect to see.