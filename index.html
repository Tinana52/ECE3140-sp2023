<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>ECE3140 / CS3420 Final Project Page by ece3140-sp2023</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">ECE3140 Final Project Page</h1>
      <h3 class="project-name">Hear the Colors!</h3>
      <h4 class="project-tagline">Canwen Zhang (cz236), Cheng Tang (ct628)</h4>
      
      <a href="https://github.coecis.cornell.edu/ece3140-sp2023/base-page" class="btn">View base-page on GitHub</a>
    </section>

<section class="main-content">
 
<!-- <h3>Welcome to your ECE3140 / CS 3420 GitHub Page!</h3>
<p>This branch of the project is set up as a basic project web-page for you to edit.</p> 
<p>You should update (and remove) this text.</p>  
<p>You can edit this file direclty or use any other method to update/generate your page. In order to update the material, 
    push to the "gh-pages" branch. Also note, that while the repo is private the <strong>page content is public</strong>.</p>
<hr> -->

<!-- <h2>System Overview</h2> 
<p>For our project “Hear the Colors!”, the main goal is to design a machine that could transform color into sound, so that we can compose a song using different colors.
<p>To implement this project, we will mainly use a color sensor and a buzzer in addition to our FRDM-KL46Z board. One way to interact with this machine is to first prepare different colors on a long piece of paper, then insert this paper into our machine box (which has the color sensor in it) and slowly pull the one end of that piece of paper through the box. Then as the paper is pulled through and the color on it is scanned by the color sensor, the sensor will send the RGB data corresponding to that color back to the board and our buzzer could then generate sound with different frequencies based on the color. Through some careful arrangement of the colors, we could even play some famous songs using the machine.</p>

<p>For peripherals we plan to use the TCS3200 color sensor and a common piezo buzzer. In terms of the hardware, the TCS3200 color sensor reads color by using a 8x8 photodiode array, then it uses the current-to-frequency converter to output a square wave whose frequency is related to  light intensity of that color. It can do this procedure for all three primary colors red, green, and blue, so by comparing the ratio between RGB readings we would be able to distinguish more than 3 colors. This is simply because all the colors can be obtained by mixing RGB colors with a different ratio. Another reason for choosing this sensor is that TCS3200 takes digital inputs and outputs, so we believe it should not be too hard to interface it with a microcontroller like our ARM Cortex M0 processor. After we read the data and determine the frequency wanted, we send a signal in PWM to the piezo buzzer. The buzzer part might sound easy, but it requires us to change the frequency of the PWM signal which might require some more work than if we were to achieve the same thing on a platform like Arduino (although the idea behind should be similar). On the software side, the overall general structure is to write a forever running loop where inside we keep reading the RGB data from the digital pin of the board and compare its values with a certain defined threshold. But once the RGB data exceeds that threshold which means the sensor has detected a color, an interrupt should be generated which should transfer the control to our ISR. Next, in the ISR it quickly compares that RGB data with some ranges we pre-defined to figure out the color and sends the corresponding PWM signal to the piezo buzzer. This way we are able to distinguish colors and play different sounds based on the colors.</p>

<h3>Current Progress -- May 5, 2023</h3>
  
<p>Compared to last time, we obtained a more detailed understanding of our TCS3200 sensor. As mentioned above, the sensor transmits color information by outputting 50% duty cycle square waves of different frequencies (i.e. it sets a digital pin high/low at different speeds depending on the color). Therefore, by using polling to continuously check the state of the OUT pin and enable/disable the PIT timer when the OUT state changes, we are able to calculate the period (1/frequency) of the square wave. In this way, we only need to monitor the state of a pin over time and do not have to employ any communication protocol such as serial to talk to our sensor. One thing to note is that, because the color could change anytime which means we cannot predict when the frequency of the square wave will change, we need to keep calculating the period and remember to reset our PIT timer after every round of recording.</p>

<p>As we are trying to interface the sensor, one slight difficulty is that, instead of reading all three RGB data at one time, our sensor is only able to read one of the colors at a time. This means we need to repeat the above procedure three times in order to collect the complete RGB information for a given color. That is, we have to constantly set and clear pins S2 and S3 in order to change the color filter so that we could switch to reading a different color. This can be achieved through a conditional for-loop that keeps going through the three colors and sets up the filter accordingly. For the frequency scaling factor (controlled by S0 and S1), we decide to set the to 20% for now (S0=1, S1=0) which gives us an intermediate frequency range and also an intermediate accuracy (tradeoff between detection range and accuracy). </p>

<p>On the hardware side, we have soldered the header pin socket to the board so that we could be more flexible in case we want to switch pins halfway through the project. For wiring, we selected PTD2(D9), PTD4(D10), PTD6(D11), PTD7(D12), PTD3(D2) to be connected with S0, S1, S2, S3, and OUT on TCS3200 color sensor, respectively. We choose those pins because they seem to be pure GPIO pins and do not have any extra default functionality or “strange” setting that might interfere with our basic reading/writing operation.</p>

<p>Finally, we have just started on the buzzer side of the project which might require us to use a PWM signal. So we decided to use PTC8 (D6) pin on the board to control it since it is also a PWM pin. We have looked into some SDK examples on MCUxpresso about PWM and will continue to work on it during the following days.</p>
   -->
  
<!-- <h3>Web Check-In</h3>

<p>Please remove this page and write a short paragraph on your progress to date and make a draft for the System Overview 
    section. Are there any major obstacles?</p>
<p>You can also start putting in the structure for the final page, but we will only be looking at the System Overview 
     for now. Your project page should have the following sections (which are similar to the lab reports).</p>
 
 
<ul>
<li>A Descriptive Project Name</li>
<li>Introduction</li>
<li>System Overview &lt;--- Draft for Web Check In</li>
<li>Project Video Demo (~3-4min)</li>
<li>Detailed Technical Description</li>
<li>Additional Resources Used</li>
<li>Work Distribution (skip if you work by yourself)</li>
</ul> -->

<!-- <hr>
<h2> Section Details </h2>  -->
<!-- Here is a more detailed breakdown of what the different sections should have.  -->
<h2>Introduction</h2>
<!-- <ol>
<li>Motivation of your project. If appropriate, consider the impact of your system public health, safety, and 
  welfare as well as relevant global, cultural, social, environmental, and economic factors.</li>
<li>Describes briefly what their system does.</li>
<li>Include any necessary background information.</li>
<li>Summary of what you have accomplished and what you have learned.</li>
</ol> -->
  <p>In this project, we designed a machine that could transform color into sound, so that we can compose a song using different colors. Using RGB data measured by a color sensor, the FRDM board could send different control signals to the piezo buzzer thus making it play different frequency sounds.</p>

  <p>In the perspective of society, this project offers a unique medium for artistic expression, enabling individuals to compose music based on colors.This will promote creativity, cultural enrichment, and personal well-being. Moreover, our project may enhance accessibility for individuals with visual impairments by allowing them to perceive and interact with various  colors through sound, i.e. hearing the sound!</p>

  <p>In designers’ perspective, we learned how to iteratively design a system through multiple design cycles, testing, and refining ideas based on the system’s feedback. We also get acquainted with the process of setting up hardwares and doing coding work after carefully learning the datasheet and reference manual.</p>

  
<h2> System Overview and diagram </h2>
<!-- Give a high-level description of how the system works and how the different parts work together. 
Include a block diagram of the system showing how components interact. This diagram could potentially be replaced by very clear writing. (You don't need the diagram for the web check-in).
       -->
  <img src="block_diagram.png" alt="diagram" width="800" height="533">
  
  <p>As shown in the high-level diagram above, there are two main peripherals used: a color sensor and a buzzer. After setting up the color sensor, it will read color by using a 8x8 photodiode array, then using a current-to-frequency converter to output a 50% duty cycle square wave whose frequency is related to light intensity of that color, as shown in the figure below.</p>
  <div style="text-align: center;">
    <img src="color_sensor.png" alt="diagram" width="600" height="200">
  </div>
  
  <p>It can do this procedure for all three primary colors red, green, and blue, so by comparing the ratio between RGB readings we would be able to distinguish more than 3 colors. Then, with the RGB data, we can then send control signals to the piezo buzzer to generate a certain frequency sound corresponding to the detected color.</p>
  
  <p>Here, the key points are: 1. How to calculate the frequency of the received square wave; 2. What should be the appropriate RGB range for each color; 3. How to control the passive piezo buzzer. The first and last key points will be discussed in detail in the technical description section below, and the second point will be elaborated in the testing section.</p>
  
<h2>Video</h2> 
The video should have the right length (3-4 min, if shorter than 2 min or longer than 5 mins, we will deduct points) 
The video should be self-contained, i.e. understandable by someone who has not read your whole website.
<ol>
<li> Give a brief overview of the project. </li>
<li> Show the system working. </li>
<li> Describe some of the technical details. </li>
</ol> 

<ul>
<li> What would be the most interesting piece of information for your fellow students? </li>
<li> Was there a super tricky bug? </li>
<li> Something surprising you learned during the implementation? </li>
<li> Did you come up with some super clever tests? </li>
</ul>
      
<h2> Technical description </h2>
  <div style="text-align: center;">
    <img src="schematic.png" alt="diagram" width="600" height="265">
  </div>
  <p>Electronically, the TCS3200 color sensor utilizes photodiodes’ sensitivity to light to detect the intensity of a color. In short, when the intensity of a light is high (i.e. more of that color is present), the photodiodes would be forward biased more which allow more current to flow through. This DC current would then be used to power a crystal oscillator on the sensor to generate a square wave; the larger the current, the higher the frequency. This is the reason that allows us to determine the presence of a certain color by only looking at the frequency (or period) of the square wave. For the sensor to work correctly for our purposes, some calibration is required. All the calibration is done by adjusting the logic level of pins S0,1,2,3. First, the sensor allows the user to choose between a frequency scaling of 2%, 20%, and 100%. A higher frequency scaling implies a smaller response time or a faster measurement rate but risks losing accuracy and becoming more susceptible to environmental noise (tradeoff). For our purpose, we choose 20% since we are not interested in measuring any fast-moving object. This implies we need to set S0 to HIGH and S1 to LOW; this setup is made at the beginning of the program and will not be changed. Next, the sensor is not able to read all three RGB data at one time, so we also need to tell the sensor when to read which color by turning on the corresponding color filter. This is achieved by pin S2 and S3 (e.g. S2=LOW and S3=HIGH turns on the filter for color blue). This setup is initialized in the beginning but will keep changing throughout the program because we constantly need the updated information about the RGB data to make the correct decision on the color. Since the sensor outputs a digital square wave with its color information being encoded into its frequency, we should be able to communicate with it by monitoring the state of the OUT pin on the sensor, especially how long it stays high/low. In this case, we do not really care about the absolute time, but instead we are only interested in how the relative period is compared among R, G, B. This way, we use a counter that keeps incrementing while the OUT pin remains high/low which then allows us to use its value for comparison between RGB to know which component dominates. This approach requires us to know when the input is high/low which could be achieved by utilizing the interrupt flags. We set the interrupt flag to be triggered on either rising edge or falling edge and keep counting while no flag is set. After obtaining the RGB data, we have a series of if-statements comparing the relative RGB values and control the buzzer based on the result.</p>
  <p>For the buzzer, we use a passive buzzer and control its sound frequency by turning it on and off at different rates. In order for it to produce a smooth sound without too much noise, it is important to turn it on and off continuously at a regular frequency. However, for our program, the buzzer is only turned on/off when we have determined the color which means we do not control the buzzer while we are taking the RGB measurements. This means there would be some hard-to-avoid irregularity in turning on/off the buzzer because the code for measuring RGB values has to be run every time before controlling the buzzer. To mitigate its negative effect, we come up with two solutions. First, whenever we have successfully identified the color and want the buzzer to beep, instead of turning it on/off for 1 time, we want to use a for-loop to do it twice which we believe should reduce some noise at some frequencies (intuitively, think it as buzzer is now interrupted less often). Indeed, this would add some extra delay, but such small delay is negligible and imperceptible to human ears since the code is run at extremely fast speed. Another way is to simply make the period longer (lower frequency) by adding more time between turning on and off. Sound with a larger period is less sensitive to variations or irregularities in the period and thus is less affected by such kinds of noise.</p>
  <p>As an overall design review, we employ polling to keep checking the state of the OUT pin and therefore communicate with the sensor. This is acceptable in this case because we only have a few peripherals or I/O to interact with. But we believe it is also possible to implement interrupt in this case. One idea would be to keep counting in the main() function and use the value of the counter to do the same comparison in the interrupt handler and reset the counter right before we exit.</p>  

<h2> Testing </h2>
<p>The primary testing strategy was to divide the project into two pairs with the FRDM board as the center: sensor-board and board-buzzer. If those two subparts could work appropriately, then we believe the process of combining them should be relatively easy. For the board-buzzer pair, we create a separate file just to test different ways of beeping a buzzer and to select the proper delay if we want a certain frequency, especially if we would like a musical note. For the sensor-board pair, the key part to test is whether we are able to check interrupt flags correctly and therefore keep track of the interval between each interrupt (i.e. period of the square wave). At the beginning of the project, this was tested with the sensor and an LED instead of a buzzer because a LED is a little easier to interact with and also more distinct to observe any output just by looking if it is lit up. At first, we just wanted the board to pick some data from the sensor no matter its actual value, so we toggle the LED whenever the RGB value is non-zero. Therefore, if we see LED blinks, we would know that the board is picking up non-trivial data from the sensor.</p>
<p>Next, for interpreting the sensor’s outputs, it is up to us to make the final decision to define what is the color being read. This step requires a lot of testing since we need to find out, given a color, how it corresponds to each of the RGB values. For example, the color purple probably has more red and blue than green which means a smaller R and B value but a larger G value. Repeating this procedure for different colors could potentially consume a long time and involves a lot of trial & error. To find a proper range, we break the code into small blocks based on the color, verify the correct functionality of individual parts, and then combine all the parts together and verify again as a whole. For each individual color, we first place the correct color in front and check if the buzzer beeps; if it does not, we adjust the RGB values in the if-statement and try again. We repeat this process until right at the point when the buzzer steadily beeps as a color is placed in front. It is important not to go too much beyond this point because otherwise we might have set a range so loose that the sensor might beep also for other unintended colors. We prevent this by also placing similar but slightly different colors in front to make sure the buzzer would not beep (e.g. blue v.s. cyan, red v.s. purple). Finally, we put all the blocks for each color back together as a final check to ensure the entire program also functions correctly.</p>
  
<h2> Work Distribution </h2>
<!-- Talk about how you split up the work and made sure that everyone contributed.  -->
  <p>For this project, most of the work was done together, including coming up with the initial idea, studying the hardware datasheet, coding, and testing. Cheng devoted more time on debugging the code and Canwen spent more time on calibrating buzzer frequencies. For creating the webpage and the demo video, we splitted tasks and did them separately.</p>
      
      
</section>

  
</body>
</html>
